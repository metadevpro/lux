import {
  Component,
  Input,
  Output,
  EventEmitter,
  OnDestroy,
  OnInit,
  forwardRef
} from '@angular/core';
import { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';
import { Subject, Observable, Subscription } from 'rxjs';
import { debounceTime } from 'rxjs/operators';

/** Filter component to query for objects. */
@Component({
  selector: 'lux-filter',
  templateUrl: './filter.component.html',
  styleUrls: ['./filter.component.scss'],
  providers: [
    {
      provide: NG_VALUE_ACCESSOR,
      multi: true,
      useExisting: forwardRef(() => FilterComponent)
    }
  ]
})
export class FilterComponent
  implements ControlValueAccessor, OnInit, OnDestroy
{
  static idCounter = 0;

  private touched = false;
  private _searchValue = '';

  @Input() disabled = false;
  /** id for the input. If left blank, it is autogenerated */
  @Input() inputId: string;
  /** Placeholder default text. */
  @Input() placeholder = '';
  /** Search value introduced by the user. */
  @Input()
  get searchValue(): string {
    return this._searchValue;
  }
  set searchValue(v: string) {
    v = (v || '').toString();
    if (v === this._searchValue) {
      return;
    }
    this.onChange(v);
    this._searchValue = v;
  }
  /** Search on type: (default true) Auto-search when user types in. */
  @Input() searchOnType = true;
  /** Custom aria label in case of not using a label */
  @Input('aria-label') ariaLabel: string;

  private debounceValue = 300; // 300 ms
  /** Debounce time in milliseconds. (defaults to 300 ms) */
  @Input()
  set debounce(val: number) {
    this.debounceValue = val;
    this.recreateObservable();
  }
  get debounce(): number {
    return this.debounceValue;
  }

  /** Search value changed by user. */
  @Output() searchValueChange = new EventEmitter<string>();

  searchValue$: Observable<string>;

  private subject = new Subject<string>();
  private sub: Subscription;

  constructor() {
    this.recreateObservable();
  }

  // ControlValueAccessor Interface
  onChange = (value) => {};
  onTouched = () => {};
  writeValue(value: any) {
    this.searchValue = (value || '').toString();
  }
  registerOnChange(onChange: any) {
    this.onChange = onChange;
  }
  registerOnTouched(onTouched: any) {
    this.onTouched = onTouched;
  }
  markAsTouched() {
    if (!this.touched) {
      this.onTouched();
      this.touched = true;
    }
  }
  setDisabledState(disabled: boolean) {
    this.disabled = disabled;
  }
  // End ControlValueAccessor Interface

  ngOnInit() {
    this.inputId = this.inputId
      ? this.inputId
      : `filter$${FilterComponent.idCounter++}`;
  }
  ngOnDestroy() {
    this.freeSubscriptions();
  }
  clear() {
    this.searchValue = '';
    this.search();
  }
  search() {
    this.searchValueChange.emit(this.searchValue);
  }
  keyup(event: KeyboardEvent, newValue: string) {
    this.markAsTouched();
    this.searchValue = newValue;
    if (event.key === 'Enter') {
      this.searchNow(this.searchValue);
    }
    if (this.searchOnType) {
      this.addEvent();
    }
  }
  onInputValueChange(newValue: string) {
    this.markAsTouched();
    this.searchValue = newValue;
  }

  private recreateObservable(): void {
    this.searchValue$ = this.subject
      .asObservable()
      .pipe(debounceTime(this.debounce));

    this.freeSubscriptions();
    this.sub = this.searchValue$.subscribe((value) => {
      this.searchValueChange.emit(value);
    });
  }
  private freeSubscriptions() {
    if (this.sub) {
      this.sub.unsubscribe();
      this.sub = null;
    }
  }
  private searchNow(value: string) {
    this.searchValueChange.emit(value);
  }
  private addEvent() {
    this.subject.next(this.searchValue);
  }
}
